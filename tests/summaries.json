["1. Import the necessary libraries and modules: `math`, `re`, `traceback`, `openai`, `github`, `tabulate`, and `tqdm`.\n2. Import specific entities from the `sweepai.core.entities` module: `ProposedIssue`, `SandboxResponse`, `Snippet`, `NoFilesException`, `SweepContext`, `MaxTokensExceeded`, and `EmptyRepository`.\n3. Import specific functions from the `sweepai.handlers.create_pr` module: `create_pr_changes`, `create_config_pr`, and `safe_delete_sweep_branch`.\n4. Import specific functions from the `sweepai.handlers.on_comment` module: `on_comment`.\n5. Import specific functions from the `sweepai.handlers.on_review` module: `review_pr`.\n6. Import specific functions from the `sweepai.utils.buttons` module: `create_action_buttons`.\n7. Import specific classes from the `sweepai.utils.chat_logger` module: `ChatLogger`.\n8. Import specific classes from the `sweepai.config.client` module: `SweepConfig` and `get_documentation_dict`.\n9. Import specific variables from the `sweepai.config.server` module: `ENV`, `MONGODB_URI`, `OPENAI_API_KEY`, `GITHUB_BOT_USERNAME`, `GITHUB_LABEL_NAME`, `OPENAI_USE_3_5_MODEL_ONLY`, and `WHITELISTED_REPOS`.\n10. Import specific functions from the `sweepai.utils.ticket_utils` module.\n11. Import specific functions from the `sweepai.utils.event_logger` module: `posthog`.\n12. Import specific functions from the `sweepai.utils.github_utils` module: `ClonedRepo` and `get_github_client`.\n13. Import specific classes from the `sweepai.utils.prompt_constructor` module: `HumanMessagePrompt`.\n14. Import specific functions from the `sweepai.utils.search_utils` module: `search_snippets`.\n15. Import specific classes from the `sweepai.utils.tree_utils` module: `DirectoryTree`.\n16. Set the OpenAI API key to the value of `OPENAI_API_KEY`.\n17. Move any code that can be moved out of `on_ticket.py` into `ticket_utils.py`, excluding the core logic.\n18. Ensure that the code is losslessly summarized in an ordered list for an engineer to search for relevant code to solve the GitHub issue.", "1. The `on_ticket` function is decorated with `@LogTask()` for logging purposes.\n2. The function takes several parameters including `title`, `summary`, `issue_number`, `issue_url`, `username`, `repo_full_name`, `repo_description`, `installation_id`, `comment_id`, and `edited`.\n3. The `strip_sweep` function is called to extract values for `title`, `slow_mode`, `do_map`, `subissues_mode`, `sandbox_mode`, `fast_mode`, and `lint_mode`.\n4. The `summary` is modified using regular expressions to remove certain patterns.\n5. The GitHub client is obtained using `get_github_client` function.\n6. The current issue is retrieved using `repo.get_issue`.\n7. The assignee of the issue is determined and stored in `assignee` variable.\n8. A `ChatLogger` object is created if `MONGODB_URI` is not None.\n9. The paying user status, trial user status, and whether to use a faster model are determined based on the `ChatLogger` object and other conditions.\n10. The `use_faster_model` flag is set to `True` if `fast_mode` is `True`.\n11. A `SweepContext` object is created with relevant parameters.\n12. If `comment_id` is not provided and the ticket is not edited, a successful ticket is added to the `ChatLogger`.\n13. Metadata related to the ticket is stored in the `metadata` dictionary.\n14. A \"started\" event is captured using `posthog.capture`.\n15. If the current issue is closed, a warning is logged and the function returns with a failure reason.\n16. The summary of the issue is updated using `current_issue.edit`.\n17. The comment to react to is determined based on `comment_id` and `current_issue`.\n18. The text of the replies to the comment is generated using a template and the comments associated with the issue.\n19. The list of open pull requests for the repository is obtained using `repo.get_pulls`.\n20. For each pull request, if it is owned by the bot and mentions the issue number in its body, the sweep branch associated with the pull request is safely deleted.\n21. A reaction with \"eyes\" is added to the item to react to.\n22. If the bot has reacted with \"rocket\" to the item to react to, the reaction is deleted.\n23. A list of progress headers is defined.\n24. The number of tickets allocated for the user is determined based on the user type.\n25. The number of tickets left for the user is calculated based on the ticket count stored in the `ChatLogger`.\n26. The payment message and payment message start are generated based on the user type and ticket count.\n27. A function `get_comment_header` is defined to generate the comment header based on the progress index, error status, PR message, and done status.\n28. The previous comment made by the bot is found in the list of comments.\n29. If the repository is empty, a first comment is created indicating that Sweep is not supported on empty repositories.\n30. The `SweepConfig` for the repository is obtained.\n31. A `ClonedRepo` object is created for the repository.\n32. The number of files in the repository is determined using `cloned_repo.get_num_files_from_repo`.\n33. An indexing message is generated based on the number of files.\n34. A first comment is created with the comment header, indexing message, and other information.", "1. If `issue_comment` is None, set `issue_comment` to `current_issue.create_comment(first_comment)`, otherwise edit comment via `issue_comment.edit(first_comment)`.\n2. Define a function `edit_sweep_comment` that takes in a message, index, pr_message, and done flag. This function updates the progress bar in the issue comment with the provided message and other information.\n3. Initialize variables `past_messages` as an empty dictionary and `current_index` as 0.\n4. Define a variable `table` and set it to None.\n5. Check if the length of `title + summary` is less than 20 characters. If it is, log an info message and call `edit_sweep_comment` with a message asking the user to add more details to the issue.\n6. Check if `repo_name` is not in the whitelist of repositories and the user is not a paying or trial user. If it is not, check if the repository name contains \"sweep\" or \"test\". If it does, log an info message and call `edit_sweep_comment` with a message informing the user that Sweep does not work on test repositories.\n7. If `lint_mode` is True, iterate over an empty list of file paths and call `SweepBot.run_sandbox` with the repository URL, file path, and other parameters.\n8. Log an info message indicating that relevant files are being fetched.\n9. Try to search for snippets and tree in the cloned repository using the `search_snippets` function. If an exception occurs, log the error and call `edit_sweep_comment` with a message informing the user about the error and asking them to add more details to the issue.\n10. Post-process the snippets to limit the number of snippets and exclude certain snippets if necessary.\n11. If `repo_description` is empty, set it to \"No description provided.\"\n12. Extract summaries from external sources based on the message summary.\n13. Extract relevant documentation based on the title, message summary, and user dictionary.\n14. Create a `HumanMessagePrompt` object with various parameters including the repository name, issue URL, username, repo description, title, summary, snippets, and tree.\n15. Perform context pruning to exclude certain snippets and directories from the analysis.\n16. Create a `DirectoryTree` object and parse the tree string.\n17. Remove excluded directories from the directory tree.\n18. Update the snippets and tree variables based on the pruned results.\n19. Create a new `HumanMessagePrompt` object with the updated parameters.\n20. Create a `SweepBot` object from the system message content, repository, and other parameters.\n21. Check if the `sweep.yaml` file exists in the repository. If it does not, create a new pull request to add the `sweep.yaml` file.\n22. If the `sweep.yaml` file already exists, log an info message.", "1. Analyze snippets in the repository and generate a plan.\n2. If `do_map` is True, generate subissues and create them as child issues of the current issue.\n3. Edit the current issue to include a summary and a checklist of the subissues.\n4. Create comments to indicate the progress of creating subissues.\n5. If no files need to be modified, provide an error message.\n6. Summarize the snippets and validate the file change requests.\n7. Generate a table displaying the proposed changes for each file.\n8. Generate a pull request based on the proposed changes.\n9. Update the current issue to include a checklist of the file change requests.\n10. Make the pull request and update the progress of each file change request.\n11. Edit the current issue to include a collapsible checklist of the file change requests.\n12. Set `delete_branch` to False.\n13. Create a generator to make the necessary changes for the pull request.\n14. Edit a comment to include the checklist of the file change requests.\n15. Set `response` to an error message indicating that no files need to be modified.", "1. Iterate through a generator and check if each item is a dictionary.\n2. If an item is a dictionary, assign it to the variable `response` and exit the loop.\n3. If an item is not a dictionary, assign its values to the variables `file_change_request`, `changed_file`, `sandbox_response`, and `commit`.\n4. Define a lambda function `format_exit_code` that returns a checkmark if the exit code is 0, otherwise returns a cross mark with the exit code.\n5. Print the value of `sandbox_response` using a logger.\n6. Create collapsible error logs if `sandbox_response` exists.\n7. If `changed_file` is True, print \"Changed File!\" and assign values to `commit_hash` and `commit_url`.\n8. Create a list of checkboxes with progress information based on the values of `checkboxes_progress`.\n9. If `changed_file` is False, print \"Didn't change file!\" and create a list of checkboxes with progress information based on the values of `checkboxes_progress`.\n10. Create a string representation of the checkboxes contents.\n11. Create a collapsible section for the checkboxes.\n12. Get the issue object from the repository using the issue number.\n13. Edit the issue body by appending the summary and checkboxes collapsible section.\n14. Print the progress of files and the name of the edited file.\n15. Call the `edit_sweep_comment` function with the checkboxes contents and a value of 2.\n16. Check if the response from the generator is successful. If not, raise an exception with the error message.\n17. Assign the pull request changes to the variable `pr_changes`.\n18. Call the `edit_sweep_comment` function with a message indicating the completion of coding the issue and a value of 3.\n19. Create a string representation of the change location.\n20. Create a review message with the self-reviews of the changes.\n21. Delete the reaction from the current issue.\n22. Set `changes_required` to False.\n23. Call the `review_pr` function with various parameters to review the pull request and assign the return values to `changes_required` and `review_comment`.\n24. Append the first review comment to the review message.\n25. If changes are required, call the `edit_sweep_comment` function with a message indicating the addressing of suggestions and a value of 3.\n26. Print the review comment being addressed.\n27. Call the `on_comment` function to handle the addressed review comment.\n28. If an exception occurs during the review process, log the error.\n29. If changes are required, call the `edit_sweep_comment` function with a message indicating the incorporation of changes and a value of 3.\n30. If no changes are required, call the `edit_sweep_comment` function with a message indicating the completion of code review without errors and a value of 3.\n31. Check if the PR is a draft and create the pull request accordingly.\n32. Add a label to the pull request.\n33. Add a reaction to the current issue.\n34. Run GitHub actions to trigger checks on the pull request.\n35. Call the `edit_sweep_comment` function with a success message and a value of 4, and include the PR URL.\n36.", "1. If `MaxTokensExceeded` exception is raised, log the error and edit the sweep comment accordingly. If the user is a paying user, display a specific error message, otherwise display a general error message. Set `delete_branch` to True and raise the exception.\n2. If `NoFilesException` exception is raised, log the error and edit the sweep comment to inform the user that no appropriate files were found. Set `delete_branch` to True and raise the exception.\n3. If `InvalidRequestError` exception is raised, log the error, edit the sweep comment to inform the user about the context length issue, and capture the error using Posthog. Set `delete_branch` to True and raise the exception.\n4. If `SystemExit` exception is raised, raise it.\n5. If any other exception is raised, log the error and edit the sweep comment accordingly. If the length of `title` and `summary` is less than 60 characters, display a specific error message, otherwise display a general error message. Log the error using Posthog and raise the exception.\n6. If no exception is raised, delete the reaction and create a new reaction on the item to react to.\n7. Finally, delete the cloned repository.\n8. If `delete_branch` is True, delete the branch associated with the pull request. If the branch name does not start with \"sweep/\", raise an exception.\n9. Capture the success event using Posthog and log the success message."]
