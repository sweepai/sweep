import re
from sweepai.config.client import (
    UPDATES_MESSAGE,
    SweepConfig,
)
from sweepai.core.entities import Snippet
from sweepai.utils.chat_logger import discord_log_error

sep = "\n---\n"
bot_suffix_starring = (
    "‚≠ê If you are enjoying Sweep, please [star our"
    " repo](https://github.com/sweepai/sweep) so more people can hear about us!"
)
bot_suffix = (
    f"\n{sep}\n{UPDATES_MESSAGE}\n{sep} üí° To recreate the pull request edit the issue"
    " title or description. To tweak the pull request, leave a comment on the pull request."
)
discord_suffix = f"\n<sup>[Join Our Discord](https://discord.com/invite/sweep)"

stars_suffix = (
    "‚≠ê In the meantime, consider [starring our repo](https://github.com/sweepai/sweep)"
    " so more people can hear about us!"
)

collapsible_template = """
<details {opened}>
<summary>{summary}</summary>

{body}
</details>
"""

checkbox_template = "- [{check}] {filename}\n{instructions}\n"

num_of_snippets_to_query = 30
total_number_of_snippet_tokens = 15_000
num_full_files = 2

ordinal = lambda n: str(n) + (
    "th" if 4 <= n <= 20 else {1: "st", 2: "nd", 3: "rd"}.get(n % 10, "th")
)

SLOW_MODE = False
SLOW_MODE = True


def clean_logs(logs: str):
    cleaned_logs = re.sub(r"\x1b\[.*?[@-~]", "", logs.replace("```", "\`\`\`"))
    cleaned_logs = re.sub('\n{2,}', '\n', cleaned_logs)
    cleaned_logs = cleaned_logs or "(nothing was outputted)"
    return cleaned_logs


def post_process_snippets(
    snippets: list[Snippet],
    max_num_of_snippets: int = 5,
    exclude_snippets: list[str] = [],
):
    snippets = [
        snippet
        for snippet in snippets
        if not any(
            snippet.file_path.endswith(ext) for ext in SweepConfig().exclude_exts
        )
    ]
    snippets = [
        snippet
        for snippet in snippets
        if not any(
            snippet.file_path == exclude_file for exclude_file in exclude_snippets
        )
    ]
    for snippet in snippets[:num_full_files]:
        snippet = snippet.expand()

    # snippet fusing
    i = 0
    while i < len(snippets):
        j = i + 1
        while j < len(snippets):
            if snippets[i] ^ snippets[j]:  # this checks for overlap
                snippets[i] = snippets[i] | snippets[j]  # merging
                snippets.pop(j)
            else:
                j += 1
        i += 1

    # truncating snippets based on character length
    result_snippets = []
    total_length = 0
    for snippet in snippets:
        total_length += len(snippet.get_snippet())
        if total_length > total_number_of_snippet_tokens * 5:
            break
        result_snippets.append(snippet)
    return result_snippets[:max_num_of_snippets]


def create_collapsible(summary: str, body: str, opened: bool = False):
    return collapsible_template.format(
        summary=summary, body=body, opened="open" if opened else ""
    )


def blockquote(text: str):
    return f"<blockquote>{text}</blockquote>" if text else ""


def create_checkbox(title: str, body: str, checked: bool = False):
    return checkbox_template.format(
        check="X" if checked else " ", filename=title, instructions=body
    )


def strip_sweep(text: str):
    return (
        re.sub(
            r"^[Ss]weep\s?(\([Ss]low\))?(\([Mm]ap\))?(\([Ff]ast\))?\s?:", "", text
        ).lstrip(),
        re.search(r"^[Ss]weep\s?\([Ss]low\)", text) is not None,
        re.search(r"^[Ss]weep\s?\([Mm]ap\)", text) is not None,
        re.search(r"^[Ss]weep\s?\([Ss]ubissues?\)", text) is not None,
        re.search(r"^[Ss]weep\s?\([Ss]andbox?\)", text) is not None,
        re.search(r"^[Ss]weep\s?\([Ff]ast\)", text) is not None,
        re.search(r"^[Ss]weep\s?\([Ll]int\)", text) is not None,
    )

def log_error(is_paying_user, is_trial_user, username, issue_url, error_type, exception, priority=0):
        if is_paying_user or is_trial_user:
            if priority == 1:
                priority = 0
            elif priority == 2:
                priority = 1

        prefix = ""
        if is_trial_user:
            prefix = " (TRIAL)"
        if is_paying_user:
            prefix = " (PRO)"

        content = (
            f"**{error_type} Error**{prefix}\n{username}:"
            f" {issue_url}\n```{exception}```"
        )
        discord_log_error(content, priority=priority)